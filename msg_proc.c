/*
 * msg_proc.c: implementation of the remote procedure "printmessage"
 *
 * Source: ?Using rpcgen?, http://www.cisco.com/en/US/docs/ios/sw_upgrades/interlink/r2_0/rpc_pr/rprpcgen.html
 */

#include <stdio.h>
#include <stdlib.h>
#include <rpc/rpc.h>	/* always needed */
#include "msg.h"	/* need this too: msg.h will be generated by rpcgen */


int append_l = 7;
int count_l = 6;
int find_l = 5;
char divider = '\n';
char *test;

/* TODO
	error handling of some kind
		too long
		not a sentence
		just generally wrong form
			no brackets, etc
	not having everything called append_l
	call from command line?
		if not fn for cleaning up the args
	split on '.' not necessarily newline?
	rename to user and text-server
	do something with the return value?
	case sensitivity?
	README describing what is done by each
	pseudocode with discussion
	what happens with each fn if the file is empty, append works...but the rest?
	comments
	debugging..........
*/
/* Used to get the file length and then reset the file pointer to the start of the file */
int get_file_length (FILE *f) {
	fseek(f, 0, SEEK_END);
	int l = ftell(f);
	fseek(f, 0, SEEK_SET);
	return l;
}

/* Gets the next sentence (max length 100) of the file, returns the length of the sentence */
int get_next_sentence(FILE *f, char *sen, int l) {
	if (f==NULL) return -1;
	fscanf(f, "%100c", sen);
	printf("%d     %d\n",ftell(f), l);
	
	for (int i = 0;(i<100||!feof(f)); i++) {
		if (*(sen+i)=='\n') {
			*(sen+i+1) = '\0';
			return i;
		}
	}
	if (ftell(f)>=l) {
		return l;
	}
	return -1;
}


/* Appends the given sentence to the end of the file */
int *append_1_svc (char **msg, struct svc_req *rqstp) {
	static int result; /* must be static! */
	FILE *f;

	f = fopen("output.txt", "a");// opens output file 
	if (f == NULL) 
	{
		result = 0;
		return (&result);
	}
	char s[100];
	char *m = s;
	strncpy(m, *msg+append_l, strlen(*msg)-append_l-1);
	s[strlen(*msg)-append_l-1] = '\0';
	fprintf(f, "%s\n", m);//writes message
	fclose(f);

	result = 1; //success
	return (&result);
}

/* Deletes all incidences of the given word from the file. */
int *delete_1_svc (char **msg, struct svc_req *rqstp) {
	static int result; /* must be static! */
	FILE *f;
	f = fopen("output.txt", "r");
	if (f == NULL) 
	{
		result = 0;
		return (&result);
	}
	char s[100]; //get rid of word and brackets - should be a function
	char *m = s;
	strncpy(m, *msg+append_l, strlen(*msg)-append_l-1);
	s[strlen(*msg)-append_l-1] = '\0';

	int l = get_file_length(f);

	char new[l], temp[100], temp2[100];
	int k = 0;
	for (int i = 0; i<l; i++) {
		fseek(f, i, SEEK_SET);
		i = i+get_next_sentence(f,temp,l);
		printf("deleeeete %d \n",i);
		char w[100];
		for (int j = 0; j<strlen(temp); j++) {
			char *t;
			t= temp+j;
			sscanf(t,"%s",w);
			printf("%d     %s\n",j, w);
			if (!strcmp(w,m)) {
				strcpy(temp2, t+strlen(w));
				strcpy(t, temp2+1);
			}
			j = j+strlen(w);
		
		}
		strcpy(new+k,temp);
		k = k+strlen(temp);
			
	}
	fclose(f);
	f = fopen("output.txt", "w");
	fprintf(f, "%s", new);
	fclose(f);
	result = 1;
	return &result;
}


/* Removes the first incidence of the given sentence from the file */
int *remove_1_svc (char **msg, struct svc_req *rqstp){
	static int result; /* must be static! */
	FILE *f;
	f = fopen("output.txt", "r");
	if (f == NULL) 
	{
		result = 0;
		return (&result);
	}
	char s[100]; //get rid of word and brackets - should be a function
	char *m = s;
	strncpy(m, *msg+append_l, strlen(*msg)-append_l-1);
	s[strlen(*msg)-append_l-1] = '\0';

	int l = get_file_length(f);

	char new[l], temp[100];
	int j = 0;
	for (int i = 0; i<l; i++) {
		fseek(f, i, SEEK_SET);
		i = i+get_next_sentence(f,temp,l);
		temp[strlen(temp)-1] = '\0';
		char *w;
		if (i<l) {
		printf("comparison:\n%s\n%s\n%d\n", temp, m, strcmp(temp,m));
			if (strcmp(temp,m)) {
				temp[strlen(temp)] = '\n';
				strcpy(new+j,temp);
				j = j+strlen(temp);
				printf("%s\n", new);
			}
		}
			
	}
	fclose(f);
	f = fopen("output.txt", "w");
	fprintf(f, "%s", new);
	fclose(f);
	result = 1;
	return &result;
}

/* Finds and returns the nth sentence in the file */
char **find_1_svc (char **msg, struct svc_req *rqstp) {
	static char * result;
	FILE *f;
	f = fopen("output.txt", "r");// opens output file 
	if (f == NULL) 
	{
		result = NULL;
		return (&result);
	}
	int l = get_file_length(f);
	int x;
	char s[100]; //get rid of word and brackets
	char *m = s;
	strncpy(m, *msg+find_l, strlen(*msg)-find_l-1);

	s[strlen(*msg)] = '\0';
	x = atoi(m);
	int j = 0;
	char *temp = malloc(sizeof(char)*100);
	for (int i = 0; i<x; i++) {
		j = j+1+get_next_sentence(f,temp,l);
		printf("find length %d  %d\n",l, j);
		
		if (j>l) {
			printf("\n\n\n\n\n\n");
			printf("and now...");
			strcpy(temp, "There are fewer lines than the number entered.");
			result = temp;
			return &result;
		}
		else {
			fseek(f, j, SEEK_SET);
		}
	}
	result = temp;
	return &result;

}

/* Finds the first incidence of a given word and returns that sentence. */

char **search_1_svc (char **msg, struct svc_req *rqstp){
	static char *result; /* must be static! */
	FILE *f;
	f = fopen("output.txt", "r");
	if (f == NULL) 
	{
		return NULL;
	}
	char s[100]; //get rid of word and brackets - should be a function
	char *m = s;
	strncpy(m, *msg+append_l, strlen(*msg)-append_l-1);
	s[strlen(*msg)-append_l-1] = '\0';

	int l = get_file_length(f);

	char *temp = malloc(sizeof(char)*100);
	for (int i = 0; i<l; i++) {
		fseek(f, i, SEEK_SET);
		i = i+get_next_sentence(f,temp,l);
		char w[100];
		for (int j = 0; j<strlen(temp); j++) {
			char *t;
			t= temp+j;
			sscanf(t,"%s",w);
			printf("%d     %s\n",j, w);
			if (!strcmp(w,m)) {
				printf("found it\n%s", temp);
				result = temp;
				return &result;
			}
			j = j+strlen(w);
		
		}
	}
	fclose(f);
	strcpy(temp, "The word you entered is not in a sentence.");
	result = temp;
	return &result;
}

/* Counts how many times the given word occurs in the file. */
int *count_1_svc (char **msg, struct svc_req *rqstp) {

	static int result; /* must be static! */
	FILE *f;

	char s[100]; //get rid of word and brackets
	char *m = s;
	strncpy(m, *msg+count_l, strlen(*msg)-count_l-1);
	s[strlen(*msg)-count_l-1] = '\0';
	f = fopen("output.txt", "r"); // opens output file 
	if (f == NULL) 
	{
		result = -1;
		return (&result);
	}
	int l = get_file_length(f);
	int count = 0;
	char t[l];
	char * temp = t;
	char * format;
	for (int i=0;i<l;i++) {
		fscanf(f, "%s", temp);
		int word_len = strlen(temp);
		if (temp[word_len-1]=='.') {
			temp[word_len-1] = '\0';
		}
		printf("temp %s   %d    %d    %d\n", temp, i, word_len, count);
		if (!strcmp(temp, m)) {
			printf("match %s\n", temp); 
			count++;
		}
		i = i+word_len;
		fseek(f,i,SEEK_SET);
		printf("end %s   %d     %d    %d\n", temp, i, word_len, count);
	}

	fclose(f);
	result = count;
	return (&result);
}
