/*
 * rprintmsg.c: remote version of "printmsg.c"
 *
 * Source: ?Using rpcgen?, http://www.cisco.com/en/US/docs/ios/sw_upgrades/interlink/r2_0/rpc_pr/rprpcgen.html
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpc/rpc.h>	/* always needed */
#include "msg.h"	/* need this too: msg.h will be generated by rpcgen */

#define append_l 7
#define count_l 6
#define find_l 5

static char* app = "APPEND";
static char* del = "DELETE";
static char* cnt = "COUNT";
static char* fnd = "FIND";
static char* rmv = "REMOVE";
static char* srch = "SEARCH";



static int * ret = 0;

int sanitize(char *msg, int fn_len) {
	int l = strlen(msg);

	if (l-fn_len-1 >100) { //msg is longer than allowed
		printf("Too many characters in the sentence. Expected less than 100.\n");
		return 0;
	}
	if ((msg[l-1]!=')')||(msg[fn_len-1]!='(')) {
		printf("Expected brackets around the word/sentence.\n");
		return 0;
	}
	char t[100];
	msg[l-1] = '\0';
	strcpy(t,msg+fn_len);
	strcpy(msg,t);
	return 1;
}

int *dispatch(char *input, CLIENT *cl) {
	if (!memcmp(input, app, strlen(app))&&sanitize(input,append_l)) {
		printf("appending\n");
		return append_1(&input, cl);
	}
	if (!memcmp(input, del, strlen(del))&&sanitize(input,append_l)) {
		printf("deleting\n");
		return delete_1(&input, cl);
	}
	if (!memcmp(input, cnt, strlen(cnt))&&sanitize(input,count_l)) {
		ret = count_1(&input, cl);
		if (*ret !=-1) {
			printf("counting %d\n", *ret);
			*ret = *ret||1;
			return ret;
		}
		ret = 0;
		return ret;
	}
	if (!memcmp(input, fnd, strlen(fnd))&&sanitize(input,find_l)) {
		int i;
		if (i = atoi(input)) {
			printf("start\n");
			char **x = find_1(&i, cl);
			printf("before if\n");
			if (x!=NULL) {
				*ret = 1;
				printf("finding \n%s\n", *x);
				return ret;
			}
			return ret;
		}
		else {
			printf("Please enter an integer as the argument to find.\n");
		}
	}
	if (!memcmp(input, srch, strlen(fnd))&&sanitize(input,append_l)) {
		char **x = search_1(&input, cl);
		if (x!=NULL) {
			printf("searching, \n%s\n",*x);
			*ret = 1;
			return ret;
		}
		return ret;
		
	}
	if (!memcmp(input, rmv, strlen(rmv))&&sanitize(input,append_l)) {
		printf("removing\n");
		return remove_1(&input, cl);
	}
	printf("invalid fn\n");
	return NULL;
}


int main(int argc, char *argv[])
{

	CLIENT *cl;
	int *result;
	char *server;
	char *message;

	ret = malloc(sizeof(int));

	if (argc != 3) {
		fprintf(stderr, "usage: %s host message\n", argv[0]);
		exit(1);
	}

	/*
	 * Save values of command line arguments
	 */

	server = argv[1];
	message = argv[2];
	

	/*
	 * Create client "handle" used for calling MESSAGEPROG on the
	 * server designated on the command line. We tell the RPC package
	 * to use the "tcp" protocol when contacting the server.
	 */

	printf("%s\n", message);

	cl = clnt_create(server, MESSAGEPROG, MESSAGEVERS, "tcp");
	if (cl == NULL) {
		/*
		 * Couldn't establish connection with server.
		 * Print error message and die.
		 */
		clnt_pcreateerror(server);
		exit(1);
	}
	
	/*
	 * Call the remote procedure "printmessage" on the server
	 */
	result = dispatch(message, cl);
	if (result == NULL) {
		/*
		 * An error occurred while calling the server.
		 * Print error message and die.
		 */
		clnt_perror(cl, server);
		exit(1);
	}

	/*
	 * Okay, we successfully called the remote procedure.
	 */
	if (*result == 0) {
		/*
		 * Server was unable to print our message.
		 * Print error message and die.
		 */
		fprintf(stderr, "%s: %s couldn't print your message\n",
			argv[0], server);
		exit(1);
	}
	
	/*
	 * The message was output on the server
	 */
	printf("Message delivered to %s!\n", server);
	return 0;
}
